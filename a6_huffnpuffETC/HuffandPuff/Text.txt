Personally, I find the MutableInt method the most attractive, since it doesn't require loading any third-party classes. So unless I discover problems with it, that's the way I'm most likely to go
something help me omg
ds us to -35, our third byte.  And so on.The whole idea for the encoder, then, is to read in a  le, construct a Hu man tree based onthe frequency of bytes in a  le, run through each byte in the  le and  gure out its Hu man bitsequence, concatenate 
all the bits together, and save the tree and the bit sequence to disk in a new,smaller  le.  Decoding is basically the reverse:  read in the Hu man tree and bit sequence,  thenuse the tree to decode the sequence into an array of bytes.
  Save the bytes to disk and you havereconstructed the original  le.One more thing to worry about:  how to go from a sequence of bits to a byte, and vice versa?We  will  have  a  lecture  about  bit  twiddling  and  bitwise  logical 
  operations.   Individual  bits  canbe manipulated and extracted by ANDing and ORing with a single bit in a particular position.  Isuggest that you take a look at this code and  gure out how it works, but in any case, I'm providingit 
  for your use (Figure 2).  Notice that we're using integers to represent bits { 32 times more spacethan we need!  But it's the easiest alternative.The  rst step is to read in all of the bytes of a  le (speci ed as a command line argument),
  using a FileInputStream.  You can call the stream's available() m
utations object is as follows(Base case) If I am a Permutations object of list length 0, do nothing, except to note that Ishould always return false when hasNext() is called.(Recursive case) 
Remove and remember the  rst element (c) from the list.Create and remember a new Permutations object (P) with the leftover list.
Obtain and remember the  rst permutation (L) from this new object, or an empty list if ithas none (because it is size 0).Initialize an index counter (i) to 0.2

Each time the next() method is called on a Permutations object, it should do the following:Return a copy ofLwithcinserted at positioni.  Incrementi.Onceibecomes too large,
 setLtoP.next() and resetito 0.IfPhas no next permutation, then this object is  nished as well.  hasNext() should returnfalse from here on out.Here's how it works for the list [0, 1, 2]:
 For each permutation of [1, 2],
 Insert 0 into each position in the list.Thus successive calls to next() return [0, 1, 2], [1, 0, 2], [1, 2, 0], [0, 2, 1], [2, 0, 1] and [2, 1, 0].After this last list is returned, hasNext() should return false.Hint:The list you return
 should be a newly-created one, either a LinkedList or an ArrayList(your choice), with elements copied over.  Don't try to use the same list that you were given in theconstructor, because you'd be disassembling it and reassembling it at 
 multiple levels of recursion,and it's almost impossible to keep it straight and do it right.Extra Credit:You should really think about doing this one, because it's a great way to testyour Permutations object.  Use your Permutations object 
 to implement the exponential NP sortthat we talked about in class.  Generate all of the permutations of a list in turn, checking each oneto see if it's sorted.  Stop when you  nd the sorted list.  How long a list can you sort using thisalgorithm,
 before the time it takes becomes intolerable?3    Hu man encoding and decoding (50 points)Your  nal major program for CSII will be to create a pair of command-line programs to compressand decompress arbitrary  les.  This will require some bit-level
 operations, creating a Comparablebinary tree class that will be used to create bit encodings, and using various Collections classes forcounting, sorting and mapping.Hu man codes have been around since the early  fties, and are still used for
 data compression.Modern compression methods use Hu man codes as part of the algorithm,  and then layer othercompression techniques on top.  Hu man codes are general-purpose { they can be used to compressany arbitrary byte stream { though they 
 re generally less ecient then special-purpose approachesthat apply only to speci c kinds of data.The basic idea behind Hu man codes is to represent bytes as variable-length bit strings, ratherthan having every byte be represented by eight bits.
 If commonly-occurring bytes require only twoor three bits instead of eight,  while very uncommon bytes are represented with ten or  fteen,  itadds up to a win in  le size.Coding and decoding Hu man codes is based on building a binary tree structure
 known as aHu man tree.  The leaves of the tree represent the bytes of the original  le.  The path through atree from leaf to root (for encoding) or from root to leaf (for decoding) yields a sequence of bits thatcode for that particular byte.  The
 tree is built in such a way that common bytes are located nearthe root, while rare ones are located far down the tree.  The easiest way to illustrate the process iswith an example.3
Suppose the byte sequence we wish to encode is [-35, 41, -35, 41, 116, -35, 22, -35, 116] (bytesin Java are always signed, so they range in value from -128 to +127).  The  rst step is to countthe number of occurrences of each byte value:  
[-35:4, 22:1, 41:2, 116:2].  Now create Hu man leavesfor each byte, putting them into a priority queue sorted according to their frequency count.  Thenrepeatedly pull pairs of nodes out of the priority queue and connect them via a new 
parent node.This  node's  value  should  be  the  total  of  the  values  of  its  children.   Put  the  node  back  into  thepriority queue, and continue the process (illustrated in Figure 1) until you have a single node.  Younow have 
 Hu man tree built according to byte frequency.To encode a byte, start at the leaf of the tree represented by that byte and traverse up the treeuntil you reach the root.  Every branching where you came from the left is represented by a
 '0',while every branching where you came from the right is a '1' (make sure you build the codes upin the correct order, from right to left).  Thus the bit strings for our example are:  [-35:0, 116:10,22:110, 41:111].  Notice how common
 values are represented with short strings and uncommon oneswith long, just as we intended.  The bit sequence of our original byte string (9 bytes of 8 bits each)was 72 bits long; our encoded string is 17 bits:  01110111100110010.Decoding 
 a string of bits is simply reversing the process.  Starting from the root of the tree andtaking each bit in turn from the bit string, follow the corresponding branch through the tree untilyou end at a leaf.  The byte represented by that lea
 f is the one you want.  In our example, the  rstbit of the code is 0.  We take the left branch from the root and end up at the -35 leaf.  There's our rst byte.  The next bit is a 1; we take the right branch at the root and we are not yet at
 a leaf.The next bit is 1; we take the right branch again.  Still no leaf.  The next bit is 1 again, and nowwe've arrived at the 41 leaf, our second byte.  Starting from the root again, the next bit is 0, whichleads us to -35, our third byte. 
 And so on.The whole idea for the encoder, then, is to read in a  le, construct a Hu man tree based onthe frequency of bytes in a  le, run through each byte in the  le and  gure out its Hu man bitsequence, concatenate all the bits together, and
 save the tree and the bit sequence to disk in a new,smaller  le.  Decoding is basically the reverse:  read in the Hu man tree and bit sequence,  thenuse the tree to decode the sequence into an array of bytes.  Save the bytes to disk and you haver
 econstructed the original  le.One more thing to worry about:  how to go from a sequence of bits to a byte, and vice versa?We  will  have  a  lecture  about  bit  twiddling  and  bitwise  logical  operations.   Individual  bits  canbe manipulated an
 d extracted by ANDing and ORing with a single bit in a particular position.  Isuggest that you take a look at this code and  gure out how it works, but in any case, I'm providingit for your use (Figure 2).  Notice that we're using integers to represent
 bits { 32 times more spacethan we need!  But it's the easiest alternative.The  rst step is to read in all of the bytes of a  le (speci ed as a command line argument),using a FileInputStream.  You can call the stream's available() method to  nd out how big 
 yourbyte array must be, and then simply call the read method with your byte array as an argument.Now construct your Hu man leaf nodes.  This class should contain a pointer to a parent andtwo  children  (labeled  \zero"  and  \one").   It  should  also  have
 a  variable  to  represent  the  node'sfrequency count,  and one to represent a particular byte.  Leaf nodes will have null children anda  lled-in byte variable, internal nodes will have null byte variables, and the root of the tree willhave a null parent. 
 Remember that this class must implement Comparable, so that it can be usedinside a PriorityQueue.  I suggest creating 256 Hu man leaves, one set to each possible byte, andwith initial counts of zero.  These can be stored in a HashMap, keyed by bytes

 Personally, I find the MutableInt method the most attractive, since it doesn't require loading any third-party classes. So unless I discover problems with it, that's the way I'm most likely to go
something help me omg
ds us to -35, our third byte.  And so on.The whole idea for the encoder, then, is to read in a  le, construct a Hu man tree based onthe frequency of bytes in a  le, run through each byte in the  le and  gure out its Hu man bitsequence, concatenate 
all the bits together, and save the tree and the bit sequence to disk in a new,smaller  le.  Decoding is basically the reverse:  read in the Hu man tree and bit sequence,  thenuse the tree to decode the sequence into an array of bytes.
  Save the bytes to disk and you havereconstructed the original  le.One more thing to worry about:  how to go from a sequence of bits to a byte, and vice versa?We  will  have  a  lecture  about  bit  twiddling  and  bitwise  logical 
  operations.   Individual  bits  canbe manipulated and extracted by ANDing and ORing with a single bit in a particular position.  Isuggest that you take a look at this code and  gure out how it works, but in any case, I'm providingit 
  for your use (Figure 2).  Notice that we're using integers to represent bits { 32 times more spacethan we need!  But it's the easiest alternative.The  rst step is to read in all of the bytes of a  le (speci ed as a command line argument),
  using a FileInputStream.  You can call the stream's available() m
utations object is as follows(Base case) If I am a Permutations object of list length 0, do nothing, except to note that Ishould always return false when hasNext() is called.(Recursive case) 
Remove and remember the  rst element (c) from the list.Create and remember a new Permutations object (P) with the leftover list.
Obtain and remember the  rst permutation (L) from this new object, or an empty list if ithas none (because it is size 0).Initialize an index counter (i) to 0.2

Each time the next() method is called on a Permutations object, it should do the following:Return a copy ofLwithcinserted at positioni.  Incrementi.Onceibecomes too large,
 setLtoP.next() and resetito 0.IfPhas no next permutation, then this object is  nished as well.  hasNext() should returnfalse from here on out.Here's how it works for the list [0, 1, 2]:
 For each permutation of [1, 2],
 Insert 0 into each position in the list.Thus successive calls to next() return [0, 1, 2], [1, 0, 2], [1, 2, 0], [0, 2, 1], [2, 0, 1] and [2, 1, 0].After this last list is returned, hasNext() should return false.Hint:The list you return
 should be a newly-created one, either a LinkedList or an ArrayList(your choice), with elements copied over.  Don't try to use the same list that you were given in theconstructor, because you'd be disassembling it and reassembling it at 
 multiple levels of recursion,and it's almost impossible to keep it straight and do it right.Extra Credit:You should really think about doing this one, because it's a great way to testyour Permutations object.  Use your Permutations object 
 to implement the exponential NP sortthat we talked about in class.  Generate all of the permutations of a list in turn, checking each oneto see if it's sorted.  Stop when you  nd the sorted list.  How long a list can you sort using thisalgorithm,
 before the time it takes becomes intolerable?3    Hu man encoding and decoding (50 points)Your  nal major program for CSII will be to create a pair of command-line programs to compressand decompress arbitrary  les.  This will require some bit-level
 operations, creating a Comparablebinary tree class that will be used to create bit encodings, and using various Collections classes forcounting, sorting and mapping.Hu man codes have been around since the early  fties, and are still used for
 data compression.Modern compression methods use Hu man codes as part of the algorithm,  and then layer othercompression techniques on top.  Hu man codes are general-purpose { they can be used to compressany arbitrary byte stream { though they 
 re generally less ecient then special-purpose approachesthat apply only to speci c kinds of data.The basic idea behind Hu man codes is to represent bytes as variable-length bit strings, ratherthan having every byte be represented by eight bits.
 If commonly-occurring bytes require only twoor three bits instead of eight,  while very uncommon bytes are represented with ten or  fteen,  itadds up to a win in  le size.Coding and decoding Hu man codes is based on building a binary tree structure
 known as aHu man tree.  The leaves of the tree represent the bytes of the original  le.  The path through atree from leaf to root (for encoding) or from root to leaf (for decoding) yields a sequence of bits thatcode for that particular byte.  The
 tree is built in such a way that common bytes are located nearthe root, while rare ones are located far down the tree.  The easiest way to illustrate the process iswith an example.3
Suppose the byte sequence we wish to encode is [-35, 41, -35, 41, 116, -35, 22, -35, 116] (bytesin Java are always signed, so they range in value from -128 to +127).  The  rst step is to countthe number of occurrences of each byte value:  
[-35:4, 22:1, 41:2, 116:2].  Now create Hu man leavesfor each byte, putting them into a priority queue sorted according to their frequency count.  Thenrepeatedly pull pairs of nodes out of the priority queue and connect them via a new 
parent node.This  node's  value  should  be  the  total  of  the  values  of  its  children.   Put  the  node  back  into  thepriority queue, and continue the process (illustrated in Figure 1) until you have a single node.  Younow have 
 Hu man tree built according to byte frequency.To encode a byte, start at the leaf of the tree represented by that byte and traverse up the treeuntil you reach the root.  Every branching where you came from the left is represented by a
 '0',while every branching where you came from the right is a '1' (make sure you build the codes upin the correct order, from right to left).  Thus the bit strings for our example are:  [-35:0, 116:10,22:110, 41:111].  Notice how common
 values are represented with short strings and uncommon oneswith long, just as we intended.  The bit sequence of our original byte string (9 bytes of 8 bits each)was 72 bits long; our encoded string is 17 bits:  01110111100110010.Decoding 
 a string of bits is simply reversing the process.  Starting from the root of the tree andtaking each bit in turn from the bit string, follow the corresponding branch through the tree untilyou end at a leaf.  The byte represented by that lea
 f is the one you want.  In our example, the  rstbit of the code is 0.  We take the left branch from the root and end up at the -35 leaf.  There's our rst byte.  The next bit is a 1; we take the right branch at the root and we are not yet at
 a leaf.The next bit is 1; we take the right branch again.  Still no leaf.  The next bit is 1 again, and nowwe've arrived at the 41 leaf, our second byte.  Starting from the root again, the next bit is 0, whichleads us to -35, our third byte. 
 And so on.The whole idea for the encoder, then, is to read in a  le, construct a Hu man tree based onthe frequency of bytes in a  le, run through each byte in the  le and  gure out its Hu man bitsequence, concatenate all the bits together, and
 save the tree and the bit sequence to disk in a new,smaller  le.  Decoding is basically the reverse:  read in the Hu man tree and bit sequence,  thenuse the tree to decode the sequence into an array of bytes.  Save the bytes to disk and you haver
 econstructed the original  le.One more thing to worry about:  how to go from a sequence of bits to a byte, and vice versa?We  will  have  a  lecture  about  bit  twiddling  and  bitwise  logical  operations.   Individual  bits  canbe manipulated an
 d extracted by ANDing and ORing with a single bit in a particular position.  Isuggest that you take a look at this code and  gure out how it works, but in any case, I'm providingit for your use (Figure 2).  Notice that we're using integers to represent
 bits { 32 times more spacethan we need!  But it's the easiest alternative.The  rst step is to read in all of the bytes of a  le (speci ed as a command line argument),using a FileInputStream.  You can call the stream's available() method to  nd out how big 
 yourbyte array must be, and then simply call the read method with your byte array as an argument.Now construct your Hu man leaf nodes.  This class should contain a pointer to a parent andtwo  children  (labeled  \zero"  and  \one").   It  should  also  have
 a  variable  to  represent  the  node'sfrequency count,  and one to represent a particular byte.  Leaf nodes will have null children anda  lled-in byte variable, internal nodes will have null byte variables, and the root of the tree willhave a null parent. 
 Remember that this class must implement Comparable, so that it can be usedinside a PriorityQueue.  I suggest creating 256 Hu man leaves, one set to each possible byte, andwith initial counts of zero.  These can be stored in a HashMap, keyed by bytes
Personally, I find the MutableInt method the most attractive, since it doesn't require loading any third-party classes. So unless I discover problems with it, that's the way I'm most likely to go
something help me omg
ds us to -35, our third byte.  And so on.The whole idea for the encoder, then, is to read in a  le, construct a Hu man tree based onthe frequency of bytes in a  le, run through each byte in the  le and  gure out its Hu man bitsequence, concatenate 
all the bits together, and save the tree and the bit sequence to disk in a new,smaller  le.  Decoding is basically the reverse:  read in the Hu man tree and bit sequence,  thenuse the tree to decode the sequence into an array of bytes.
  Save the bytes to disk and you havereconstructed the original  le.One more thing to worry about:  how to go from a sequence of bits to a byte, and vice versa?We  will  have  a  lecture  about  bit  twiddling  and  bitwise  logical 
  operations.   Individual  bits  canbe manipulated and extracted by ANDing and ORing with a single bit in a particular position.  Isuggest that you take a look at this code and  gure out how it works, but in any case, I'm providingit 
  for your use (Figure 2).  Notice that we're using integers to represent bits { 32 times more spacethan we need!  But it's the easiest alternative.The  rst step is to read in all of the bytes of a  le (speci ed as a command line argument),
  using a FileInputStream.  You can call the stream's available() m
utations object is as follows(Base case) If I am a Permutations object of list length 0, do nothing, except to note that Ishould always return false when hasNext() is called.(Recursive case) 
Remove and remember the  rst element (c) from the list.Create and remember a new Permutations object (P) with the leftover list.
Obtain and remember the  rst permutation (L) from this new object, or an empty list if ithas none (because it is size 0).Initialize an index counter (i) to 0.2

Each time the next() method is called on a Permutations object, it should do the following:Return a copy ofLwithcinserted at positioni.  Incrementi.Onceibecomes too large,
 setLtoP.next() and resetito 0.IfPhas no next permutation, then this object is  nished as well.  hasNext() should returnfalse from here on out.Here's how it works for the list [0, 1, 2]:
 For each permutation of [1, 2],
 Insert 0 into each position in the list.Thus successive calls to next() return [0, 1, 2], [1, 0, 2], [1, 2, 0], [0, 2, 1], [2, 0, 1] and [2, 1, 0].After this last list is returned, hasNext() should return false.Hint:The list you return
 should be a newly-created one, either a LinkedList or an ArrayList(your choice), with elements copied over.  Don't try to use the same list that you were given in theconstructor, because you'd be disassembling it and reassembling it at 
 multiple levels of recursion,and it's almost impossible to keep it straight and do it right.Extra Credit:You should really think about doing this one, because it's a great way to testyour Permutations object.  Use your Permutations object 
 to implement the exponential NP sortthat we talked about in class.  Generate all of the permutations of a list in turn, checking each oneto see if it's sorted.  Stop when you  nd the sorted list.  How long a list can you sort using thisalgorithm,
 before the time it takes becomes intolerable?3    Hu man encoding and decoding (50 points)Your  nal major program for CSII will be to create a pair of command-line programs to compressand decompress arbitrary  les.  This will require some bit-level
 operations, creating a Comparablebinary tree class that will be used to create bit encodings, and using various Collections classes forcounting, sorting and mapping.Hu man codes have been around since the early  fties, and are still used for
 data compression.Modern compression methods use Hu man codes as part of the algorithm,  and then layer othercompression techniques on top.  Hu man codes are general-purpose { they can be used to compressany arbitrary byte stream { though they 
 re generally less ecient then special-purpose approachesthat apply only to speci c kinds of data.The basic idea behind Hu man codes is to represent bytes as variable-length bit strings, ratherthan having every byte be represented by eight bits.
 If commonly-occurring bytes require only twoor three bits instead of eight,  while very uncommon bytes are represented with ten or  fteen,  itadds up to a win in  le size.Coding and decoding Hu man codes is based on building a binary tree structure
 known as aHu man tree.  The leaves of the tree represent the bytes of the original  le.  The path through atree from leaf to root (for encoding) or from root to leaf (for decoding) yields a sequence of bits thatcode for that particular byte.  The
 tree is built in such a way that common bytes are located nearthe root, while rare ones are located far down the tree.  The easiest way to illustrate the process iswith an example.3
Suppose the byte sequence we wish to encode is [-35, 41, -35, 41, 116, -35, 22, -35, 116] (bytesin Java are always signed, so they range in value from -128 to +127).  The  rst step is to countthe number of occurrences of each byte value:  
[-35:4, 22:1, 41:2, 116:2].  Now create Hu man leavesfor each byte, putting them into a priority queue sorted according to their frequency count.  Thenrepeatedly pull pairs of nodes out of the priority queue and connect them via a new 
parent node.This  node's  value  should  be  the  total  of  the  values  of  its  children.   Put  the  node  back  into  thepriority queue, and continue the process (illustrated in Figure 1) until you have a single node.  Younow have 
 Hu man tree built according to byte frequency.To encode a byte, start at the leaf of the tree represented by that byte and traverse up the treeuntil you reach the root.  Every branching where you came from the left is represented by a
 '0',while every branching where you came from the right is a '1' (make sure you build the codes upin the correct order, from right to left).  Thus the bit strings for our example are:  [-35:0, 116:10,22:110, 41:111].  Notice how common
 values are represented with short strings and uncommon oneswith long, just as we intended.  The bit sequence of our original byte string (9 bytes of 8 bits each)was 72 bits long; our encoded string is 17 bits:  01110111100110010.Decoding 
 a string of bits is simply reversing the process.  Starting from the root of the tree andtaking each bit in turn from the bit string, follow the corresponding branch through the tree untilyou end at a leaf.  The byte represented by that lea
 f is the one you want.  In our example, the  rstbit of the code is 0.  We take the left branch from the root and end up at the -35 leaf.  There's our rst byte.  The next bit is a 1; we take the right branch at the root and we are not yet at
 a leaf.The next bit is 1; we take the right branch again.  Still no leaf.  The next bit is 1 again, and nowwe've arrived at the 41 leaf, our second byte.  Starting from the root again, the next bit is 0, whichleads us to -35, our third byte. 
 And so on.The whole idea for the encoder, then, is to read in a  le, construct a Hu man tree based onthe frequency of bytes in a  le, run through each byte in the  le and  gure out its Hu man bitsequence, concatenate all the bits together, and
 save the tree and the bit sequence to disk in a new,smaller  le.  Decoding is basically the reverse:  read in the Hu man tree and bit sequence,  thenuse the tree to decode the sequence into an array of bytes.  Save the bytes to disk and you haver
 econstructed the original  le.One more thing to worry about:  how to go from a sequence of bits to a byte, and vice versa?We  will  have  a  lecture  about  bit  twiddling  and  bitwise  logical  operations.   Individual  bits  canbe manipulated an
 d extracted by ANDing and ORing with a single bit in a particular position.  Isuggest that you take a look at this code and  gure out how it works, but in any case, I'm providingit for your use (Figure 2).  Notice that we're using integers to represent
 bits { 32 times more spacethan we need!  But it's the easiest alternative.The  rst step is to read in all of the bytes of a  le (speci ed as a command line argument),using a FileInputStream.  You can call the stream's available() method to  nd out how big 
 yourbyte array must be, and then simply call the read method with your byte array as an argument.Now construct your Hu man leaf nodes.  This class should contain a pointer to a parent andtwo  children  (labeled  \zero"  and  \one").   It  should  also  have
 a  variable  to  represent  the  node'sfrequency count,  and one to represent a particular byte.  Leaf nodes will have null children anda  lled-in byte variable, internal nodes will have null byte variables, and the root of the tree willhave a null parent. 
 Remember that this class must implement Comparable, so that it can be usedinside a PriorityQueue.  I suggest creating 256 Hu man leaves, one set to each possible byte, andwith initial counts of zero.  These can be stored in a HashMap, keyed by bytes
Personally, I find the MutableInt method the most attractive, since it doesn't require loading any third-party classes. So unless I discover problems with it, that's the way I'm most likely to go
something help me omg
ds us to -35, our third byte.  And so on.The whole idea for the encoder, then, is to read in a  le, construct a Hu man tree based onthe frequency of bytes in a  le, run through each byte in the  le and  gure out its Hu man bitsequence, concatenate 
all the bits together, and save the tree and the bit sequence to disk in a new,smaller  le.  Decoding is basically the reverse:  read in the Hu man tree and bit sequence,  thenuse the tree to decode the sequence into an array of bytes.
  Save the bytes to disk and you havereconstructed the original  le.One more thing to worry about:  how to go from a sequence of bits to a byte, and vice versa?We  will  have  a  lecture  about  bit  twiddling  and  bitwise  logical 
  operations.   Individual  bits  canbe manipulated and extracted by ANDing and ORing with a single bit in a particular position.  Isuggest that you take a look at this code and  gure out how it works, but in any case, I'm providingit 
  for your use (Figure 2).  Notice that we're using integers to represent bits { 32 times more spacethan we need!  But it's the easiest alternative.The  rst step is to read in all of the bytes of a  le (speci ed as a command line argument),
  using a FileInputStream.  You can call the stream's available() m
utations object is as follows(Base case) If I am a Permutations object of list length 0, do nothing, except to note that Ishould always return false when hasNext() is called.(Recursive case) 
Remove and remember the  rst element (c) from the list.Create and remember a new Permutations object (P) with the leftover list.
Obtain and remember the  rst permutation (L) from this new object, or an empty list if ithas none (because it is size 0).Initialize an index counter (i) to 0.2

Each time the next() method is called on a Permutations object, it should do the following:Return a copy ofLwithcinserted at positioni.  Incrementi.Onceibecomes too large,
 setLtoP.next() and resetito 0.IfPhas no next permutation, then this object is  nished as well.  hasNext() should returnfalse from here on out.Here's how it works for the list [0, 1, 2]:
 For each permutation of [1, 2],
 Insert 0 into each position in the list.Thus successive calls to next() return [0, 1, 2], [1, 0, 2], [1, 2, 0], [0, 2, 1], [2, 0, 1] and [2, 1, 0].After this last list is returned, hasNext() should return false.Hint:The list you return
 should be a newly-created one, either a LinkedList or an ArrayList(your choice), with elements copied over.  Don't try to use the same list that you were given in theconstructor, because you'd be disassembling it and reassembling it at 
 multiple levels of recursion,and it's almost impossible to keep it straight and do it right.Extra Credit:You should really think about doing this one, because it's a great way to testyour Permutations object.  Use your Permutations object 
 to implement the exponential NP sortthat we talked about in class.  Generate all of the permutations of a list in turn, checking each oneto see if it's sorted.  Stop when you  nd the sorted list.  How long a list can you sort using thisalgorithm,
 before the time it takes becomes intolerable?3    Hu man encoding and decoding (50 points)Your  nal major program for CSII will be to create a pair of command-line programs to compressand decompress arbitrary  les.  This will require some bit-level
 operations, creating a Comparablebinary tree class that will be used to create bit encodings, and using various Collections classes forcounting, sorting and mapping.Hu man codes have been around since the early  fties, and are still used for
 data compression.Modern compression methods use Hu man codes as part of the algorithm,  and then layer othercompression techniques on top.  Hu man codes are general-purpose { they can be used to compressany arbitrary byte stream { though they 
 re generally less ecient then special-purpose approachesthat apply only to speci c kinds of data.The basic idea behind Hu man codes is to represent bytes as variable-length bit strings, ratherthan having every byte be represented by eight bits.
 If commonly-occurring bytes require only twoor three bits instead of eight,  while very uncommon bytes are represented with ten or  fteen,  itadds up to a win in  le size.Coding and decoding Hu man codes is based on building a binary tree structure
 known as aHu man tree.  The leaves of the tree represent the bytes of the original  le.  The path through atree from leaf to root (for encoding) or from root to leaf (for decoding) yields a sequence of bits thatcode for that particular byte.  The
 tree is built in such a way that common bytes are located nearthe root, while rare ones are located far down the tree.  The easiest way to illustrate the process iswith an example.3
Suppose the byte sequence we wish to encode is [-35, 41, -35, 41, 116, -35, 22, -35, 116] (bytesin Java are always signed, so they range in value from -128 to +127).  The  rst step is to countthe number of occurrences of each byte value:  
[-35:4, 22:1, 41:2, 116:2].  Now create Hu man leavesfor each byte, putting them into a priority queue sorted according to their frequency count.  Thenrepeatedly pull pairs of nodes out of the priority queue and connect them via a new 
parent node.This  node's  value  should  be  the  total  of  the  values  of  its  children.   Put  the  node  back  into  thepriority queue, and continue the process (illustrated in Figure 1) until you have a single node.  Younow have 
 Hu man tree built according to byte frequency.To encode a byte, start at the leaf of the tree represented by that byte and traverse up the treeuntil you reach the root.  Every branching where you came from the left is represented by a
 '0',while every branching where you came from the right is a '1' (make sure you build the codes upin the correct order, from right to left).  Thus the bit strings for our example are:  [-35:0, 116:10,22:110, 41:111].  Notice how common
 values are represented with short strings and uncommon oneswith long, just as we intended.  The bit sequence of our original byte string (9 bytes of 8 bits each)was 72 bits long; our encoded string is 17 bits:  01110111100110010.Decoding 
 a string of bits is simply reversing the process.  Starting from the root of the tree andtaking each bit in turn from the bit string, follow the corresponding branch through the tree untilyou end at a leaf.  The byte represented by that lea
 f is the one you want.  In our example, the  rstbit of the code is 0.  We take the left branch from the root and end up at the -35 leaf.  There's our rst byte.  The next bit is a 1; we take the right branch at the root and we are not yet at
 a leaf.The next bit is 1; we take the right branch again.  Still no leaf.  The next bit is 1 again, and nowwe've arrived at the 41 leaf, our second byte.  Starting from the root again, the next bit is 0, whichleads us to -35, our third byte. 
 And so on.The whole idea for the encoder, then, is to read in a  le, construct a Hu man tree based onthe frequency of bytes in a  le, run through each byte in the  le and  gure out its Hu man bitsequence, concatenate all the bits together, and
 save the tree and the bit sequence to disk in a new,smaller  le.  Decoding is basically the reverse:  read in the Hu man tree and bit sequence,  thenuse the tree to decode the sequence into an array of bytes.  Save the bytes to disk and you haver
 econstructed the original  le.One more thing to worry about:  how to go from a sequence of bits to a byte, and vice versa?We  will  have  a  lecture  about  bit  twiddling  and  bitwise  logical  operations.   Individual  bits  canbe manipulated an
 d extracted by ANDing and ORing with a single bit in a particular position.  Isuggest that you take a look at this code and  gure out how it works, but in any case, I'm providingit for your use (Figure 2).  Notice that we're using integers to represent
 bits { 32 times more spacethan we need!  But it's the easiest alternative.The  rst step is to read in all of the bytes of a  le (speci ed as a command line argument),using a FileInputStream.  You can call the stream's available() method to  nd out how big 
 yourbyte array must be, and then simply call the read method with your byte array as an argument.Now construct your Hu man leaf nodes.  This class should contain a pointer to a parent andtwo  children  (labeled  \zero"  and  \one").   It  should  also  have
 a  variable  to  represent  the  node'sfrequency count,  and one to represent a particular byte.  Leaf nodes will have null children anda  lled-in byte variable, internal nodes will have null byte variables, and the root of the tree willhave a null parent. 
 Remember that this class must implement Comparable, so that it can be usedinside a PriorityQueue.  I suggest creating 256 Hu man leaves, one set to each possible byte, andwith initial counts of zero.  These can be stored in a HashMap, keyed by bytes
